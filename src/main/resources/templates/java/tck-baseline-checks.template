	
	public static String debugDescribe(OdmaObject obj) {
		String result = obj instanceof OdmaClass ? "class(id=`" : obj instanceof OdmaPropertyInfo ? "property(id=`" : "object(id=`";
		try {
			OdmaId id = obj.getId();
			result = result + (id == null ? "<null>" : id.toString());
		} catch(Exception e) {
			result = result + "<except>";
		}
		if(obj instanceof OdmaClass) {
			result = result + "`, qname=`";
			try {
				OdmaQName qname = ((OdmaClass)obj).getQName();
				result = result + (qname == null ? "<null>" : qname.toString());
			} catch(Exception e) {
				result = result + "<except>";
			}
		} else if(obj instanceof OdmaPropertyInfo) {
			result = result + "`, qname=`";
			try {
				OdmaQName qname = ((OdmaPropertyInfo)obj).getQName();
				result = result + (qname == null ? "<null>" : qname.toString());
			} catch(Exception e) {
				result = result + "<except>";
			}
		}
		result = result + "`, class=`";
		try {
			OdmaClass clazz = obj.getOdmaClass();
			if(clazz == null) {
				result = result + "<null>";
			} else {
				try {
					OdmaQName qname = clazz.getQName();
					result = result + (qname == null ? "<qname-null>" : qname.toString());
				} catch(Exception e) {
					result = result + "<qname-except>";
				}
			}
		} catch(Exception e) {
			result = result + "<except>";
		}
		result = result + "`)";
		return result;
	}

    public static List<String> verifyObjectBaseline(OdmaObject obj) {
        return verifyObjectBaseline(obj, new HashSet<OdmaId>(), new HashSet<OdmaQName>());
    }

    public static List<String> verifyObjectBaseline(OdmaObject obj, HashSet<OdmaId> objectLoopCheck, HashSet<OdmaQName> classLoopCheck) {
        LinkedList<String> result = new LinkedList<>();
        if(obj.getId() == null) {
            result.add(debugDescribe(obj)+".getId() returns null");
        }
        if(objectLoopCheck.contains(obj.getId())) {
            return result;
        }
        objectLoopCheck.add(obj.getId());
        if(obj.getGuid() == null) {
            result.add(debugDescribe(obj)+".getGuid() returns null");
        }
        if(obj.getRepository() == null) {
            result.add(debugDescribe(obj)+".getRepository() returns null");
        }
        if(obj.getOdmaClass() == null) {
            result.add(debugDescribe(obj)+".getOdmaClass() returns null");
            result.add(debugDescribe(obj)+" ABORT baseline verification");
            return result;
        }
        if(obj.getOdmaClass().getProperties() == null) {
            result.add(debugDescribe(obj)+".getOdmaClass().getProperties() returns null");
            result.add(debugDescribe(obj)+" ABORT baseline verification");
            return result;
        }
        if(obj.getOdmaClass().isInstantiable() == false) {
            result.add(debugDescribe(obj)+".getOdmaClass().isInstantiable() == false");
        }
        if(obj.getOdmaClass().isAspect() == true) {
            result.add(debugDescribe(obj)+".getOdmaClass().isAspect() == true");
        }
        // check we have all properties
        OdmaClass clazz = obj.getOdmaClass();
        for(OdmaPropertyInfo pi : clazz.getProperties()) {
            OdmaProperty prop;
            try
            {
                prop = obj.getProperty(pi.getQName());
            }
            catch (OdmaPropertyNotFoundException e)
            {
                result.add(debugDescribe(obj)+": Missing property `"+pi.getQName()+"`");
                continue;
            }
            if(prop.getType() != OdmaType.fromNumericId(pi.getDataType())) {
                result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` has a different data type than described in the property info object");
            }
            if(prop.isMultiValue() != pi.isMultiValue()) {
                result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` has a different cardinality than described in the property info object");
            }
            if(pi.isRequired() && prop.getValue() == null) {
                result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` is required but has null value");
            }
            if(pi.isMultiValue() && prop.getValue() == null) {
                result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` is MultiValue but has null value");
            }
            if(pi.isMultiValue() && pi.isRequired()) {
                try {
                    if(prop.getType() == OdmaType.REFERENCE) {
                        if(!prop.getReferenceIterable().iterator().hasNext()) {
                            result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` is required but reference set does not have any elements");
                        }
                    } else {
                        List<?> list = (List<?>)prop.getValue();
                        if(list.isEmpty()) {
                            result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` is required but list does not have any elements");
                        }
                    }
                } catch(OdmaInvalidDataTypeException e) {
                    result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` caused OdmaInvalidDataTypeException");
                } catch(ClassCastException e) {
                    result.add(debugDescribe(obj)+": Property `"+pi.getQName()+"` caused ClassCastException");
                }
            }
        }
        result.addAll(verifyClassBaseline(obj.getOdmaClass(), objectLoopCheck, classLoopCheck));
        return result;
    }

    public static List<String> verifyClassBaseline(OdmaClass cls) {
        return verifyClassBaseline(cls, new HashSet<OdmaId>(), new HashSet<OdmaQName>());
    }

    public static List<String> verifyClassBaseline(OdmaClass cls, HashSet<OdmaId> objectLoopCheck, HashSet<OdmaQName> classLoopCheck) {
        List<String> result = verifyObjectBaseline(cls, objectLoopCheck, classLoopCheck);
        if(!result.isEmpty()) {
            result.add(debugDescribe(cls)+": Object baseline test failed");
            result.add(debugDescribe(cls)+" ABORT class baseline verification");
            return result;
            
        }
        if(cls.getName() == null) {
            result.add(debugDescribe(cls)+".getName() returns null");
        }
        if(cls.getNamespace() == null) {
            result.add(debugDescribe(cls)+".getNamespace() returns null");
        }
        if(cls.getQName() == null) {
            result.add(debugDescribe(cls)+".getQName() returns null");
            result.add(debugDescribe(cls)+" ABORT class baseline verification");
            return result;
        }
        if(classLoopCheck.contains(cls.getQName())) {
            return result;
        }
        classLoopCheck.add(cls.getQName());
        if(cls.getProperties() == null) {
            result.add(debugDescribe(cls)+".getProperties() returns null");
            result.add(debugDescribe(cls)+" ABORT class baseline verification");
            return result;
        }
        if(cls.getProperties().iterator().hasNext() == false) {
            result.add(debugDescribe(cls)+".getProperties().iterator().hasNext() == false");
            result.add(debugDescribe(cls)+" ABORT class baseline verification");
            return result;
        }
        if(cls.getDeclaredProperties() == null) {
            result.add(debugDescribe(cls)+".getDeclaredProperties() returns null");
            result.add(debugDescribe(cls)+" ABORT class baseline verification");
            return result;
        }
        if(cls.getAspects() == null) {
            result.add(debugDescribe(cls)+".getAspects() returns null");
        }
        if(cls.getSuperClass() != null) {
            if(cls.isAspect() != cls.getSuperClass().isAspect()) {
                result.add(debugDescribe(cls)+".isAspect() != cls.getSuperClass().isAspect()");
            }
            if(cls.getSuperClass().getSubClasses() == null) {
                result.add(debugDescribe(cls)+".getSuperClass().getSubClasses() == null");
            }  else {
                boolean found = false;
                for(OdmaClass superSubClass : cls.getSuperClass().getSubClasses()) {
                    if(superSubClass.getQName().equals(cls.getQName())) {
                        found = true;
                    }
                }
                if(!found) {
                    result.add(debugDescribe(cls)+".getSuperClass().getSubClasses() does not contain cls");
                }
            }
            HashSet<OdmaQName> classHierarchyLoopCheck = new HashSet<OdmaQName>();
            classHierarchyLoopCheck.add(cls.getQName());
            OdmaClass s = cls.getSuperClass();
            String loop = cls.getQName().toString();
            while(s != null) {
                loop = loop+"->"+s.getQName();
                if(classHierarchyLoopCheck.contains(s.getQName())) {
                    result.add(debugDescribe(cls)+": Class HierarchyLoopCheck failed. Loop: "+loop);
                    break;
                }
                s = s.getSuperClass();
            }
        }
        if(cls.getSubClasses() == null) {
            result.add(debugDescribe(cls)+".getSubClasses() == null");
        } else {
            for(OdmaClass subClass : cls.getSubClasses()) {
                if(subClass.getSuperClass() == null) {
                    result.add(debugDescribe(cls)+".getSubClasses()[].getSuperClass() == null for cls.getSubClasses()["+debugDescribe(subClass)+"]");
                } else if(!subClass.getSuperClass().getQName().equals(cls.getQName())) {
                    result.add(debugDescribe(cls)+".getSubClasses()[].getSuperClass().getQName() != cls.getQName() for cls.getSubClasses()["+debugDescribe(subClass)+"]");
                }
            }
        }
        HashMap<OdmaQName, OdmaPropertyInfo> superProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        if(cls.getSuperClass() != null) {
            for(OdmaPropertyInfo pi : cls.getSuperClass().getProperties()) {
                if(pi.getQName() == null) {
                    result.add(debugDescribe(cls.getSuperClass())+" contains "+debugDescribe(pi)+" with getQName()==null");
                    continue;
                }
                if(superProps.containsKey(pi.getQName())) {
                    result.add(debugDescribe(cls.getSuperClass())+" contains multiple property infos with duplicate QName "+pi.getQName());
                    continue;
                }
                superProps.put(pi.getQName(), pi);
            }
        }
        if(cls.isAspect()) {
            if(cls.getAspects().iterator().hasNext()) {
                result.add(debugDescribe(cls)+" is declared as Aspect but does have aspects itself");
            }
        }
        HashSet<OdmaQName> superClassAspectNames = new HashSet<OdmaQName>();
        if(cls.getSuperClass() != null) {
            for(OdmaClass superAspect : cls.getSuperClass().getAspects()) {
                superClassAspectNames.add(superAspect.getQName());
            }
        }
        HashMap<OdmaQName, OdmaPropertyInfo> aspectProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        HashSet<OdmaQName> aspectNames = new HashSet<OdmaQName>();
        for(OdmaClass aspect : cls.getAspects()) {
            if(!aspect.isAspect()) {
                result.add(debugDescribe(cls)+" aspect "+debugDescribe(aspect)+" has isAspect()==false");
            }
            if(!aspect.isInstantiable()) {
                result.add(debugDescribe(cls)+" aspect "+debugDescribe(aspect)+" has isInstantiable()==false");
            }
            aspectNames.add(aspect.getQName());
            for(OdmaPropertyInfo pi : aspect.getProperties()) {
                if(pi.getQName() == null) {
                    result.add(debugDescribe(cls)+" aspect "+debugDescribe(aspect)+" contains property info with getQName()==null");
                    continue;
                }
                if(aspectProps.containsKey(pi.getQName())) {
                    result.add(debugDescribe(cls)+ " imports multiple properties with same name through aspects: "+pi.getQName());
                    continue;
                }
                if(!superClassAspectNames.contains(aspect.getQName()) && superProps.containsKey(pi.getQName())) {
                    result.add(debugDescribe(cls)+" imports aspect "+debugDescribe(aspect)+" with naming conflict of property "+debugDescribe(pi)+" with inherited properties from super class");
                }
                aspectProps.put(pi.getQName(), pi);
            }
        }
        HashMap<OdmaQName, OdmaPropertyInfo> allProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        for(OdmaPropertyInfo pi : cls.getProperties()) {
            if(pi.getQName() == null) {
                result.add(debugDescribe(cls)+" contains "+debugDescribe(pi)+" with getQName()==null");
                continue;
            }
            if(allProps.containsKey(pi.getQName())) {
                result.add(debugDescribe(cls)+" contains multiple property infos with duplicate QName "+pi.getQName());
                continue;
            }
            allProps.put(pi.getQName(), pi);
        }
        HashMap<OdmaQName, OdmaPropertyInfo> declaredProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        for(OdmaPropertyInfo pi : cls.getDeclaredProperties()) {
            if(pi.getQName() == null) {
                result.add(debugDescribe(cls)+" contains declared "+debugDescribe(pi)+" with getQName()==null");
                continue;
            }
            if(declaredProps.containsKey(pi.getQName())) {
                result.add(debugDescribe(cls)+" contains multiple declared property infos with duplicate QName "+pi.getQName());
                continue;
            }
            declaredProps.put(pi.getQName(), pi);
            if(superProps.containsKey(pi.getQName())) {
                if(pi.getDataType() == OdmaType.REFERENCE.getNumericId()) {
                    String piDiff = propInfoDiff(pi,superProps.get(pi.getQName()),true);
                    if(piDiff != null) {
                        result.add(debugDescribe(cls)+" declared property "+debugDescribe(pi)+" conflicts with inherited properties from superclass. Both are reference but have different specs: "+piDiff);
                    }
                    if(!isOrExtends(superProps.get(pi.getQName()).getReferenceClass().getQName(),pi.getReferenceClass())) {
                        result.add(debugDescribe(cls)+" declared property "+debugDescribe(pi)+" conflicts with inherited properties from superclass. Both are reference but reference class of declared prop does not extend reference class of super prop: "+pi.getReferenceClass().getQName()+" is not and does not extend "+superProps.get(pi.getQName()).getReferenceClass().getQName());
                    }
                } else {
                    result.add(debugDescribe(cls)+" declares property "+debugDescribe(pi)+" with naming conflict with inherited properties from super class");
                }
            }
            if(aspectProps.containsKey(pi.getQName())) {
                result.add(debugDescribe(cls)+" declares property "+debugDescribe(pi)+" with naming conflict with inherited properties from aspects");
            }
            if(!allProps.containsKey(pi.getQName())) {
                result.add(debugDescribe(cls)+" declared property "+debugDescribe(pi)+" is missing in getProperties()");
            } else {
                String piDiff = propInfoDiff(pi,allProps.get(pi.getQName()),false);
                if(piDiff != null) {
                    result.add(debugDescribe(cls)+" declared property "+debugDescribe(pi)+" is different in getProperties(): "+piDiff);
                }
            }
        }
        for(OdmaPropertyInfo pi : superProps.values()) {
            if(!allProps.containsKey(pi.getQName())) {
                result.add(debugDescribe(cls)+" inherited superclass property "+debugDescribe(pi)+" not part of properties");
            } else {
                String piDiff = propInfoDiff(pi,allProps.get(pi.getQName()),false); 
                if(piDiff != null) {
                    result.add(debugDescribe(cls)+" inherited superclass property "+debugDescribe(pi)+" is different in getProperties(): "+piDiff);
                }
            }
        }
        for(OdmaPropertyInfo pi : aspectProps.values()) {
            if(!allProps.containsKey(pi.getQName())) {
                result.add(debugDescribe(cls)+" inherited aspect property "+debugDescribe(pi)+" not part of properties");
            } else {
                String piDiff = propInfoDiff(pi,allProps.get(pi.getQName()),false); 
                if(piDiff != null) {
                    result.add(debugDescribe(cls)+" inherited aspect property "+debugDescribe(pi)+" is different in getProperties(): "+piDiff);
                }
            }
        }
        for(OdmaQName pn : allProps.keySet()) {
            if( !superProps.containsKey(pn) && !aspectProps.containsKey(pn) && !declaredProps.containsKey(pn) ) {
                result.add(debugDescribe(cls)+" property "+pn+" is neither inherited through super class, inherited through aspects or declared");
            }
        }
        if(cls.getSuperClass() != null) {
            verifyClassBaseline(cls.getSuperClass(), objectLoopCheck, classLoopCheck);            
        }
        for(OdmaClass aspect : cls.getAspects()) {
            verifyClassBaseline(aspect, objectLoopCheck, classLoopCheck);            
        }
        if(cls.getSuperClass() != null) {
            for(OdmaClass superAspect : cls.getSuperClass().getAspects()) {
                if(!aspectNames.contains(superAspect.getQName())) {
                    result.add(debugDescribe(cls)+" inherited aspect "+debugDescribe(superAspect)+" from super class "+debugDescribe(cls.getSuperClass())+" but is missing in aspects");
                }
            }
        }
        return result;
    }

    private static String propInfoDiff(OdmaPropertyInfo piA, OdmaPropertyInfo piB, boolean ignoreReferenceClass) {
        if(!piA.getName().equals(piB.getName())) {
            return "Name is different: `"+piA.getName()+"` and `"+piB.getName()+"`";
        }
        if(!piA.getNamespace().equals(piB.getNamespace())) {
            return "Namespace is different: `"+piA.getNamespace()+"` and `"+piB.getNamespace()+"`";
        }
        if(!piA.getDisplayName().equals(piB.getDisplayName())) {
            return "DisplayName is different: `"+piA.getDisplayName()+"` and `"+piB.getDisplayName()+"`";
        }
        if(!piA.getDataType().equals(piB.getDataType())) {
            return "DataType is different: `"+piA.getDataType()+"` and `"+piB.getDataType()+"`";
        }
        if(!piA.isMultiValue().equals(piB.isMultiValue())) {
            return "MultiValue is different: `"+piA.isMultiValue()+"` and `"+piB.isMultiValue()+"`";
        }
        if(!piA.isRequired().equals(piB.isRequired())) {
            return "Required is different: `"+piA.isRequired()+"` and `"+piB.isRequired()+"`";
        }
        if(!piA.isReadOnly().equals(piB.isReadOnly())) {
            return "ReadOnly is different: `"+piA.isReadOnly()+"` and `"+piB.isReadOnly()+"`";
        }
        if(!piA.isHidden().equals(piB.isHidden())) {
            return "Hidden is different: `"+piA.isHidden()+"` and `"+piB.isHidden()+"`";
        }
        if(!piA.isSystem().equals(piB.isSystem())) {
            return "System is different: `"+piA.isSystem()+"` and `"+piB.isSystem()+"`";
        }
        if(!piA.getQName().equals(piB.getQName())) {
            return "QName is different: `"+piA.getQName()+"` and `"+piB.getQName()+"`";
        }
        if(!(piA.getChoices().iterator().hasNext() == piB.getChoices().iterator().hasNext())) {
            return "Choices presence is different: `"+piA.getChoices().iterator().hasNext()+"` and `"+piB.getChoices().iterator().hasNext()+"`";
        }
        if(piA.getChoices().iterator().hasNext()) {
            HashSet<OdmaId> choices = new HashSet<OdmaId>();
            for(OdmaChoiceValue cv : piA.getChoices()) {
                choices.add(cv.getId());
            }
            for(OdmaChoiceValue cv : piB.getChoices()) {
                if(!choices.contains(cv.getId())) {
                    return "Choice elements are different";
                }
                choices.remove(cv.getId());
            }
            if(!choices.isEmpty()) {
                return "Choice elements are different";
            }
        }
        if(!ignoreReferenceClass && piA.getDataType() == OdmaType.REFERENCE.getNumericId()) {
        	OdmaClass refClassA = piA.getReferenceClass();
        	OdmaClass refClassB = piB.getReferenceClass();
        	if(refClassA == null) {
        		return "Property Info "+piA.getQName()+" has REFERENCE type but ReferenceClass is null";
        	}
        	if(refClassB == null) {
        		return "Property Info "+piB.getQName()+" has REFERENCE type but ReferenceClass is null";
        	}
            if(!piA.getReferenceClass().getQName().equals(piB.getReferenceClass().getQName())) {
                return "ReferenceClass is different: `"+piA.getReferenceClass().getQName()+"` and `"+piB.getReferenceClass().getQName()+"`";
            }
        }
        return null;
    }

    private static boolean isOrExtends(OdmaQName name, OdmaClass cls) {
        while(cls != null) {
            if(cls.getQName().equals(name)) {
                return true;
            }
            cls = cls.getSuperClass();
        }
        return false;
    }
