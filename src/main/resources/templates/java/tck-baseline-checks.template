
    public static List<String> verifyObjectBaseline(OdmaObject obj) {
        return verifyObjectBaseline(obj, new HashSet<OdmaId>(), new HashSet<OdmaQName>());
    }

    public static List<String> verifyObjectBaseline(OdmaObject obj, HashSet<OdmaId> objectLoopCheck, HashSet<OdmaQName> classLoopCheck) {
        LinkedList<String> result = new LinkedList<>();
        if(obj.getId() == null) {
            result.add("getId() returns null");
        }
        if(objectLoopCheck.contains(obj.getId())) {
            return result;
        }
        objectLoopCheck.add(obj.getId());
        if(obj.getGuid() == null) {
            result.add("getGuid() returns null");
        }
        if(obj.getRepository() == null) {
            result.add(obj.getId()+" getRepository() returns null");
        }
        if(obj.getOdmaClass() == null) {
            result.add(obj.getId()+" getOdmaClass() returns null");
            result.add(obj.getId()+" ABORT baseline verification");
            return result;
        }
        if(obj.getOdmaClass().getProperties() == null) {
            result.add(obj.getId()+" getOdmaClass().getProperties() returns null");
            result.add(obj.getId()+" ABORT baseline verification");
            return result;
        }
        if(obj.getOdmaClass().isInstantiable() == false) {
            result.add(obj.getId()+" getOdmaClass().isInstantiable() == false");
        }
        if(obj.getOdmaClass().isAspect() == true) {
            result.add(obj.getId()+" getOdmaClass().isAspect() == true");
        }
        // check we have all properties
        OdmaClass clazz = obj.getOdmaClass();
        for(OdmaPropertyInfo pi : clazz.getProperties()) {
            OdmaProperty prop;
            try
            {
                prop = obj.getProperty(pi.getQName());
            }
            catch (OdmaPropertyNotFoundException e)
            {
                result.add("Missing property `"+pi.getQName()+"` in object with ID `"+obj.getId()+"`");
                continue;
            }
            if(prop.getType() != OdmaType.fromNumericId(pi.getDataType())) {
                result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` has a different data type than described in the property info object");
            }
            if(prop.isMultiValue() != pi.isMultiValue()) {
                result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` has a different cardinality than described in the property info object");
            }
            if(pi.isRequired() && prop.getValue() == null) {
                result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` is required but has null value");
            }
            if(pi.isMultiValue() && prop.getValue() == null) {
                result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` is MultiValue but has null value");
            }
            if(pi.isMultiValue() && pi.isRequired()) {
                try {
                    if(prop.getType() == OdmaType.REFERENCE) {
                        if(!prop.getReferenceIterable().iterator().hasNext()) {
                            result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` is required but reference set does not have any elements");
                        }
                    } else {
                        List<?> list = (List<?>)prop.getValue();
                        if(list.isEmpty()) {
                            result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` is required but list does not have any elements");
                        }
                    }
                } catch(OdmaInvalidDataTypeException e) {
                    result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` caused OdmaInvalidDataTypeException");
                } catch(ClassCastException e) {
                    result.add("Property `"+pi.getQName()+"` in object `"+obj.getId()+"` caused ClassCastException");
                }
            }
        }
        result.addAll(verifyClassBaseline(obj.getOdmaClass(), objectLoopCheck, classLoopCheck));
        return result;
    }

    public static List<String> verifyClassBaseline(OdmaClass cls) {
        return verifyClassBaseline(cls, new HashSet<OdmaId>(), new HashSet<OdmaQName>());
    }

    public static List<String> verifyClassBaseline(OdmaClass cls, HashSet<OdmaId> objectLoopCheck, HashSet<OdmaQName> classLoopCheck) {
        List<String> result = verifyObjectBaseline(cls, objectLoopCheck, classLoopCheck);
        if(!result.isEmpty()) {
            result.add("object baseline test failed for class with ID `"+cls.getId()+"`");
            result.add("ABORT class baseline verification");
            return result;
            
        }
        if(cls.getName() == null) {
            result.add(cls.getId()+" cls.getName() returns null");
        }
        if(cls.getNamespace() == null) {
            result.add(cls.getId()+" cls.getNamespace() returns null");
        }
        if(cls.getQName() == null) {
            result.add(cls.getId()+" cls.getQName() returns null");
            result.add("ABORT class baseline verification");
            return result;
        }
        if(classLoopCheck.contains(cls.getQName())) {
            return result;
        }
        classLoopCheck.add(cls.getQName());
        if(cls.getProperties() == null) {
            result.add(cls.getId()+" cls.getProperties() returns null");
            result.add("ABORT class baseline verification");
            return result;
        }
        if(cls.getProperties().iterator().hasNext() == false) {
            result.add(cls.getId()+" cls.getProperties().iterator().hasNext() == false");
            result.add("ABORT class baseline verification");
            return result;
        }
        if(cls.getDeclaredProperties() == null) {
            result.add(cls.getId()+" cls.getDeclaredProperties() returns null");
            result.add("ABORT class baseline verification");
            return result;
        }
        if(cls.getAspects() == null) {
            result.add(cls.getId()+" cls.getAspects() returns null");
        }
        if(cls.getSuperClass() != null) {
            if(cls.isAspect() != cls.getSuperClass().isAspect()) {
                result.add(cls.getId()+" cls.isAspect() != cls.getSuperClass().isAspect()");
            }
            if(cls.getSuperClass().getSubClasses() == null) {
                result.add(cls.getId()+" cls.getSuperClass().getSubClasses() == null");
            }  else {
                boolean found = false;
                for(OdmaClass superSubClass : cls.getSuperClass().getSubClasses()) {
                    if(superSubClass.getQName().equals(cls.getQName())) {
                        found = true;
                    }
                }
                if(!found) {
                    result.add(cls.getId()+" cls.getSuperClass().getSubClasses() does not contain cls");
                }
            }
            HashSet<OdmaQName> classHierarchyLoopCheck = new HashSet<OdmaQName>();
            classHierarchyLoopCheck.add(cls.getQName());
            OdmaClass s = cls.getSuperClass();
            String loop = cls.getQName().toString();
            while(s != null) {
                loop = loop+"->"+s.getQName();
                if(classHierarchyLoopCheck.contains(s.getQName())) {
                    result.add(cls.getId()+" Class HierarchyLoopCheck failed. Loop: "+loop);
                    break;
                }
                s = s.getSuperClass();
            }
        }
        if(cls.getSubClasses() == null) {
            result.add(cls.getId()+" cls.getSubClasses() == null");
        } else {
            for(OdmaClass subClass : cls.getSubClasses()) {
                if(subClass.getSuperClass() == null) {
                    result.add(cls.getId()+" cls.getSubClasses()[].getSuperClass() == null for cls.getSubClasses()[] "+subClass.getId());
                } else if(!subClass.getSuperClass().getQName().equals(cls.getQName())) {
                    result.add(cls.getId()+" cls.getSubClasses()[].getSuperClass().getQName() != cls.getQName() for cls.getSubClasses()[] "+subClass.getId());
                }
            }
        }
        HashMap<OdmaQName, OdmaPropertyInfo> superProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        if(cls.getSuperClass() != null) {
            for(OdmaPropertyInfo pi : cls.getSuperClass().getProperties()) {
                if(pi.getQName() == null) {
                    result.add("class "+cls.getSuperClass().getQName()+" contains property info with getQName()==null");
                    continue;
                }
                if(superProps.containsKey(pi.getQName())) {
                    result.add("class "+cls.getSuperClass().getQName()+" contains property info with duplicate QName "+pi.getQName());
                    continue;
                }
                superProps.put(pi.getQName(), pi);
            }
        }
        if(cls.isAspect()) {
            if(cls.getAspects().iterator().hasNext()) {
                result.add(cls.getId()+" is declared as Aspect but does have aspects itself");
            }
        }
        HashMap<OdmaQName, OdmaPropertyInfo> aspectProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        HashSet<OdmaQName> aspectNames = new HashSet<OdmaQName>();
        for(OdmaClass aspect : cls.getAspects()) {
            if(!aspect.isAspect()) {
                result.add(cls.getId()+" aspect "+aspect.getQName()+" has isAspect()==false");
            }
            if(!aspect.isInstantiable()) {
                result.add(cls.getId()+" aspect "+aspect.getQName()+" has isInstantiable()==false");
            }
            aspectNames.add(aspect.getQName());
            for(OdmaPropertyInfo pi : aspect.getProperties()) {
                if(pi.getQName() == null) {
                    result.add(cls.getId()+" aspect "+aspect.getQName()+" contains property info with getQName()==null");
                    continue;
                }
                if(aspectProps.containsKey(pi.getQName())) {
                    result.add(cls.getId()+ "class imports multiple properties with same name through aspects: "+pi.getQName());
                    continue;
                }
                if(superProps.containsKey(pi.getQName())) {
                    result.add(cls.getId()+ "class imports aspect "+aspect.getQName()+" with naming conflict of property "+pi.getQName()+" with inherited properties from super class");
                }
                aspectProps.put(pi.getQName(), pi);
            }
        }
        HashMap<OdmaQName, OdmaPropertyInfo> allProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        for(OdmaPropertyInfo pi : cls.getProperties()) {
            if(pi.getQName() == null) {
                result.add(cls.getId()+" class "+cls.getQName()+" contains property info with getQName()==null");
                continue;
            }
            if(allProps.containsKey(pi.getQName())) {
                result.add(cls.getId()+" class "+cls.getQName()+" contains property info with duplicate QName "+pi.getQName());
                continue;
            }
            allProps.put(pi.getQName(), pi);
        }
        HashMap<OdmaQName, OdmaPropertyInfo> declaredProps = new HashMap<OdmaQName, OdmaPropertyInfo>();
        for(OdmaPropertyInfo pi : cls.getDeclaredProperties()) {
            if(pi.getQName() == null) {
                result.add(cls.getId()+" class "+cls.getQName()+" contains declared property info with getQName()==null");
                continue;
            }
            if(declaredProps.containsKey(pi.getQName())) {
                result.add(cls.getId()+" class "+cls.getQName()+" contains declared property info with duplicate QName "+pi.getQName());
                continue;
            }
            declaredProps.put(pi.getQName(), pi);
            if(superProps.containsKey(pi.getQName())) {
                if(pi.getDataType() == OdmaType.REFERENCE.getNumericId()) {
                    String piDiff = propInfoDiff(pi,superProps.get(pi.getQName()),true);
                    if(piDiff != null) {
                        result.add(cls.getId()+" class "+cls.getQName()+" declared property "+pi.getQName()+" conflicts with inherited properties from superclass. both are reference but have different specs: "+piDiff);
                    }
                    if(!isOrExtends(superProps.get(pi.getQName()).getReferenceClass().getQName(),pi.getReferenceClass())) {
                        result.add(cls.getId()+" class "+cls.getQName()+" declared property "+pi.getQName()+" conflicts with inherited properties from superclass. both are reference but reference class of declared prop does not extend reference class of super prop: "+pi.getReferenceClass().getQName()+" is not and does not extend "+superProps.get(pi.getQName()).getReferenceClass().getQName());
                    }
                } else {
                    result.add(cls.getId()+ " class declares property "+pi.getQName()+" with naming conflict with inherited properties from super class");
                }
            }
            if(aspectProps.containsKey(pi.getQName())) {
                result.add(cls.getId()+ " class declared property "+pi.getQName()+" with naming conflict with inherited properties from aspects");
            }
            if(!allProps.containsKey(pi.getQName())) {
                result.add(cls.getId()+" class "+cls.getQName()+" declared property "+pi.getQName()+" is missing in getProperties()");
            } else {
                String piDiff = propInfoDiff(pi,allProps.get(pi.getQName()),false);
                if(piDiff != null) {
                    result.add(cls.getId()+" class "+cls.getQName()+" declared property "+pi.getQName()+" is different in getProperties(): "+piDiff);
                }
            }
        }
        for(OdmaPropertyInfo pi : superProps.values()) {
            if(!allProps.containsKey(pi.getQName())) {
                result.add(cls.getId()+ " inherited superclass property "+pi.getQName()+" not part of properties");
            } else {
                String piDiff = propInfoDiff(pi,allProps.get(pi.getQName()),false); 
                if(piDiff != null) {
                    result.add(cls.getId()+" class "+cls.getQName()+" inherited superclass property "+pi.getQName()+" is different in getProperties(): "+piDiff);
                }
            }
        }
        for(OdmaPropertyInfo pi : aspectProps.values()) {
            if(!allProps.containsKey(pi.getQName())) {
                result.add(cls.getId()+ " inherited aspect property "+pi.getQName()+" not part of properties");
            } else {
                String piDiff = propInfoDiff(pi,allProps.get(pi.getQName()),false); 
                if(piDiff != null) {
                    result.add(cls.getId()+" class "+cls.getQName()+" inherited aspect property "+pi.getQName()+" is different in getProperties(): "+piDiff);
                }
            }
        }
        for(OdmaQName pn : allProps.keySet()) {
            if( !superProps.containsKey(pn) && !aspectProps.containsKey(pn) && !declaredProps.containsKey(pn) ) {
                result.add(cls.getId()+" class "+cls.getQName()+" property "+pn+" is neither inherited through sper class, inherited through aspects or declared");
            }
        }
        if(cls.getSuperClass() != null) {
            verifyClassBaseline(cls.getSuperClass(), objectLoopCheck, classLoopCheck);            
        }
        for(OdmaClass aspect : cls.getAspects()) {
            verifyClassBaseline(aspect, objectLoopCheck, classLoopCheck);            
        }
        if(cls.getSuperClass() != null) {
            for(OdmaClass superAspect : cls.getSuperClass().getAspects()) {
                if(!aspectNames.contains(superAspect.getQName())) {
                    result.add(cls.getId()+" class "+cls.getQName()+" inherited aspect "+superAspect.getQName()+" from super class but is missing in aspects");
                }
            }
        }
        return result;
    }

    private static String propInfoDiff(OdmaPropertyInfo piA, OdmaPropertyInfo piB, boolean ignoreReferenceClass) {
        if(!piA.getName().equals(piB.getName())) {
            return "Name is different: `"+piA.getName()+"` and `"+piB.getName()+"`";
        }
        if(!piA.getNamespace().equals(piB.getNamespace())) {
            return "Namespace is different: `"+piA.getNamespace()+"` and `"+piB.getNamespace()+"`";
        }
        if(!piA.getDisplayName().equals(piB.getDisplayName())) {
            return "DisplayName is different: `"+piA.getDisplayName()+"` and `"+piB.getDisplayName()+"`";
        }
        if(!piA.getDataType().equals(piB.getDataType())) {
            return "DataType is different: `"+piA.getDataType()+"` and `"+piB.getDataType()+"`";
        }
        if(!piA.isMultiValue().equals(piB.isMultiValue())) {
            return "MultiValue is different: `"+piA.isMultiValue()+"` and `"+piB.isMultiValue()+"`";
        }
        if(!piA.isRequired().equals(piB.isRequired())) {
            return "Required is different: `"+piA.isRequired()+"` and `"+piB.isRequired()+"`";
        }
        if(!piA.isReadOnly().equals(piB.isReadOnly())) {
            return "ReadOnly is different: `"+piA.isReadOnly()+"` and `"+piB.isReadOnly()+"`";
        }
        if(!piA.isHidden().equals(piB.isHidden())) {
            return "Hidden is different: `"+piA.isHidden()+"` and `"+piB.isHidden()+"`";
        }
        if(!piA.isSystem().equals(piB.isSystem())) {
            return "System is different: `"+piA.isSystem()+"` and `"+piB.isSystem()+"`";
        }
        if(!piA.getQName().equals(piB.getQName())) {
            return "QName is different: `"+piA.getQName()+"` and `"+piB.getQName()+"`";
        }
        if(!(piA.getChoices().iterator().hasNext() == piB.getChoices().iterator().hasNext())) {
            return "Choices presence is different: `"+piA.getChoices().iterator().hasNext()+"` and `"+piB.getChoices().iterator().hasNext()+"`";
        }
        if(piA.getChoices().iterator().hasNext()) {
            HashSet<OdmaId> choices = new HashSet<OdmaId>();
            for(OdmaChoiceValue cv : piA.getChoices()) {
                choices.add(cv.getId());
            }
            for(OdmaChoiceValue cv : piB.getChoices()) {
                if(!choices.contains(cv.getId())) {
                    return "Choice elements are different";
                }
                choices.remove(cv.getId());
            }
            if(!choices.isEmpty()) {
                return "Choice elements are different";
            }
        }
        if(!ignoreReferenceClass && piA.getDataType() == OdmaType.REFERENCE.getNumericId()) {
            if(!piA.getReferenceClass().getQName().equals(piB.getReferenceClass().getQName())) {
                return "ReferenceClass is different: `"+piA.getReferenceClass().getQName()+"` and `"+piB.getReferenceClass().getQName()+"`";
            }
        }
        return null;
    }

    private static boolean isOrExtends(OdmaQName name, OdmaClass cls) {
        while(cls != null) {
            if(cls.getQName().equals(name)) {
                return true;
            }
            cls = cls.getSuperClass();
        }
        return false;
    }
