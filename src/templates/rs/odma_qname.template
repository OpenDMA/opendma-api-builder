use crate::OdmaError;
use std::fmt;

/// Represents an ODMA qualified name, consisting of a namespace and a name.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OdmaQName {
    namespace: String,
    name: String,
}

impl OdmaQName {

    /// Constructs a new `OdmaQName` with the given namespace and name.
    /// Panics if the namespace or name is empty or consists only of whitespace.
    pub fn new(namespace: &str, name: &str) -> Self {
        Self::try_new(namespace, name).unwrap_or_else(|e| panic!("{}", e))
    }

    /// Constructs a new `OdmaQName` with the given namespace and name.
    /// Returns an `OdmaError` if the namespace or name is empty or consists only of whitespace.
    pub fn try_new(namespace: &str, name: &str) -> Result<Self, OdmaError> {
        if namespace.trim().is_empty() {
            return Err(OdmaError::IllegalArgument("Namespace must not be empty or whitespace".into()))
        }
        if name.trim().is_empty() {
            return Err(OdmaError::IllegalArgument("Name must not be empty or whitespace".into()))
        }

        Ok(OdmaQName {
            namespace: namespace.to_string(),
            name: name.to_string(),
        })
    }

    /// Returns the namespace part of the qualified name.
    pub fn namespace(&self) -> &str {
        &self.namespace
    }

    /// Returns the name part of the qualified name.
    pub fn name(&self) -> &str {
        &self.name
    }

}

impl std::fmt::Display for OdmaQName {

    /// Formats the `OdmaQName` as a string in the format "namespace:name".
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.namespace, self.name)
    }

}


impl TryFrom<(String, String)> for OdmaQName {
    type Error = OdmaError;

    fn try_from((namespace, name): (String, String)) -> Result<Self, Self::Error> {
        Self::try_new(&namespace, &name)
    }
}