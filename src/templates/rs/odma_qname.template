use crate::OdmaError;
use std::fmt;

/// Represents an ODMA qualified name, consisting of a qualifier and a name.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OdmaQName {
    qualifier: String,
    name: String,
}

impl OdmaQName {

    /// Constructs a new `OdmaQName` with the given qualifier and name.
    /// Panics if the qualifier or name is empty or consists only of whitespace.
    pub fn new(qualifier: &str, name: &str) -> Self {
        Self::try_new(qualifier, name).unwrap_or_else(|e| panic!("{}", e))
    }

    /// Constructs a new `OdmaQName` with the given qualifier and name.
    /// Returns an `OdmaError` if the qualifier or name is empty or consists only of whitespace.
    pub fn try_new(qualifier: &str, name: &str) -> Result<Self, OdmaError> {
        if qualifier.trim().is_empty() {
            return Err(OdmaError::IllegalArgument("Qualifier must not be empty or whitespace".into()))
        }
        if name.trim().is_empty() {
            return Err(OdmaError::IllegalArgument("Name must not be empty or whitespace".into()))
        }

        Ok(OdmaQName {
            qualifier: qualifier.to_string(),
            name: name.to_string(),
        })
    }

    /// Returns the qualifier part of the qualified name.
    pub fn qualifier(&self) -> &str {
        &self.qualifier
    }

    /// Returns the name part of the qualified name.
    pub fn name(&self) -> &str {
        &self.name
    }

}

impl std::fmt::Display for OdmaQName {

    /// Formats the `OdmaQName` as a string in the format "qualifier:name".
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.qualifier, self.name)
    }

}


impl TryFrom<(String, String)> for OdmaQName {
    type Error = OdmaError;

    fn try_from((qualifier, name): (String, String)) -> Result<Self, Self::Error> {
        Self::try_new(&qualifier, &name)
    }
}