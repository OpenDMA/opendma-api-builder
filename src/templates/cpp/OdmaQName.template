#ifndef _OdmaQName_h_
#define _OdmaQName_h_

#include <string>

/**
 * Representation of a <i>qualified name</i> consisting of a name <i>qualifier</i>
 * and the <i>name</i> iteself.<br>
 * Using qualified names instead of simple Strings enables OpenDMA to mix
 * different architectures with identical names and distinguish them by their
 * qualifier.
 * 
 * \author Stefan Kopf, xaldon Technologies GmbH, the OpenDMA architecture board
 */
class OdmaQName
{

protected:

    /** the name <i>qualifier</i> of this qualified name */
    std::wstring qualifier;

    /** the <i>name</i> of this qualified name */
    std::wstring name;

public:

    /**
     * Create a new <code>OdmaQName</code> with an empty name qualifier.
     * 
     * @param name
     *            The <i>name</i> of this qualified name. Must not be null.
     *            Must not be empty.
     * 
     * @throws IllegalArgumentException
     *             if the name is null or empty
     */
    OdmaQName(const wstring& name_)
    {
        /*
        if(name == null)
        {
            throw new IllegalArgumentException("The name of a OdmaQName must not be null.");
        }
        if(name.empty())
        {
            throw new IllegalArgumentException("The name of a OdmaQName must have at least 1 character.");
        }
        */
        name = name_;
    }

    /**
     * Create a new <code>OdmaQName</code> for a given <i>name qualifier</i>
     * and <i>name</i>.
     * 
     * \param qualifier
     *            The name <i>qualifier</i> of this qualified name. Can be
     *            null. Must not be empty (if not null).
     * \param name
     *            The <i>name</i> of this qualified name. Must not be null.
     *            Must not be empty.
     * 
     * \throws IllegalArgumentException
     *             if the name is null or empty or if the qualifier is not null
     *             and empty
     */
    OdmaQName(const wstring& qualifier_, const wstring& name_)
    {
        /*
        if (name == null)
        {
            throw new IllegalArgumentException("The name of a OdmaQName may not be null.");
        }
        if ((qualifier != null) && (qualifier.length() == 0))
        {
            throw new IllegalArgumentException("The qualifier of a OdmaQName must have at least 1 character.");
        }
        if (name.length() == 0)
        {
            throw new IllegalArgumentException("The name of a OdmaQName must have at least 1 character.");
        }
        */
        qualifier = qualifier_;
        name = name_;
    }

    /**
     * Returns the name <i>qualifier</i> of this qualified name.
     * 
     * \return the qualifier of this qualified name.
     */
    const std::wstring& getQualifier()
    {
        return qualifier;
    }

    /**
     * Returns the <i>name</i> of this qualified name.
     * 
     * \return the name of this qualified name.
     */
    const std::wstring& getName()
    {
        return name;
    }

    /**
     * Compares this <code>OdmaQName</code> to the given object and returns
     * true if and only if the given object is not null and both object are
     * recognized as equal.<br>
     * Two <code>OdmaQName</code>s are equal if:<br>
     * (a) at least one qualifier is null and the names are equal, or<br>
     * (b) both qualifiers are equal and both names are equal.<br>
     * This implicates that a <code>OdmaQName</code> without a qualifier will
     * be equal to any <code>OdmaQName</code> with the same name.
     * 
     * \param qn
     *            the Object to compare this <code>OdmaQName</code> to
     * 
     * \return true if and only if this <code>OdmaQName</code> equals the
     *         given object
     */
    bool equals(OdmaQName& qn)
    {
        /*
        return (qn != null) && (qn instanceof OdmaQName) && ((((qualifier == null) || (((OdmaQName) qn).qualifier == null)) && name.equals(((OdmaQName) qn).name)) || ((qualifier != null) && qualifier
                .equals(((OdmaQName) qn).qualifier) && name.equals(((OdmaQName) qn).name)));
        */
        return false;
    }

    /**
     * Compares this <code>OdmaQName</code> to the given object and returns
     * true if and only if the given object is not null and both object are
     * recognized as equal, ignoring case considerations.<br>
     * Two <code>OdmaQName</code>s are equal if:<br>
     * (a) at least one qualifier is null and both names are equal (ignoring
     * case considerations), or<br>
     * (b) both qualifiers are equal (ignoring case considerations) and both
     * names are equal (ignoring case considerations).<br>
     * This implicates that a <code>OdmaQName</code> without a qualifier will
     * be equal to any <code>OdmaQName</code> with the same name.
     * 
     * \param qn
     *            the Object to compare this <code>OdmaQName</code> to
     * 
     * \return true if and only if this <code>OdmaQName</code> equals the
     *         given object
     */
    bool equalsIgnoreCase(OdmaQName& qn)
    {
        /*
        return (qn != null) && (qn instanceof OdmaQName) && ((((qualifier == null) || (((OdmaQName) qn).qualifier == null)) && this.name.equalsIgnoreCase(qn.name)) || ((qualifier != null) && this.qualifier
                .equalsIgnoreCase(qn.qualifier) && this.name.equalsIgnoreCase(qn.name)));
        */
        return false;
    }

}

#endif
