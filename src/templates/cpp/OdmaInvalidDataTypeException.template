#ifndef _OdmaInvalidDataTypeException_h_
#define _OdmaInvalidDataTypeException_h_

/**
 * Exception thrown whenever the data type accessed by the user does not match
 * the real data type in OpenDMA.
 * 
 * \author Stefan Kopf, xaldon Technologies GmbH, the OpenDMA architecture board
 */
class OdmaInvalidDataTypeException
{

private:

    /** the data type expected by the user */
    int expectedDataType;

    /** the multi-value / single-value property expected by the user */
    bool expectedMultivalue;

    /**
     * whether this Exception carries information about the real data type that
     * is present in OpenDMA or not
     */
    bool hasFound;

    /** the real data type that is present in OpenDMA */
    int foundDataType;

    /** the real multi-value / single-value property that is present in OpenDMA */
    bool foundMultivalue;

    /**
     * Create a new <code>OdmaInvalidDataTypeException</code> with the given
     * parameters.
     * 
     * \param expectedDataType
     *            the data type expected by the user
     * \param expectedMultivalue
     *            the multi-value / single-value property expected by the user
     */
    OdmaInvalidDataTypeException(int expectedDataType, bool expectedMultivalue)
    {
        super(getDefaultMessage(expectedDataType, expectedMultivalue));
        this.hasFound = false;
        this.expectedDataType = expectedDataType;
        this.expectedMultivalue = expectedMultivalue;
    }

    /**
     * Create a new <code>OdmaInvalidDataTypeException</code> with the given
     * parameters.
     * 
     * \param msg
     *            a message string for the user
     * \param expectedDataType
     *            the data type expected by the user
     * \param expectedMultivalue
     *            the multi-value / single-value property expected by the user
     */
    OdmaInvalidDataTypeException(const wstring&, int expectedDataType, bool expectedMultivalue)
    {
        super(msg);
        this.hasFound = false;
        this.expectedDataType = expectedDataType;
        this.expectedMultivalue = expectedMultivalue;
    }

    /**
     * Create a new <code>OdmaInvalidDataTypeException</code> with the given
     * parameters.
     * 
     * \param expectedDataType
     *            the data type expected by the user
     * \param expectedMultivalue
     *            the multi-value / single-value property expected by the user
     * \param foundDataType
     * \param foundMultivalue
     */
    public OdmaInvalidDataTypeException(int expectedDataType, bool expectedMultivalue, int foundDataType, bool foundMultivalue)
    {
        super(getDefaultMessage(expectedDataType, expectedMultivalue, foundDataType, foundMultivalue));
        this.hasFound = true;
        this.expectedDataType = expectedDataType;
        this.expectedMultivalue = expectedMultivalue;
        this.foundDataType = foundDataType;
        this.foundMultivalue = foundMultivalue;
    }

    /**
     * Create a new <code>OdmaInvalidDataTypeException</code> with the given
     * parameters.
     * 
     * \param msg
     *            a message string for the user
     * \param expectedDataType
     *            the data type expected by the user
     * \param expectedMultivalue
     *            the multi-value / single-value property expected by the user
     * \param foundDataType
     * \param foundMultivalue
     */
    public OdmaInvalidDataTypeException(const wstring& msg, int expectedDataType, bool expectedMultivalue, int foundDataType, bool foundMultivalue)
    {
        super(msg);
        this.hasFound = true;
        this.expectedDataType = expectedDataType;
        this.expectedMultivalue = expectedMultivalue;
        this.foundDataType = foundDataType;
        this.foundMultivalue = foundMultivalue;
    }

    /**
     * 
     * @param expectedDataType
     *            the data type expected by the user
     * @param expectedMultivalue
     *            the multi-value / single-value property expected by the user
     * @return x
     */
    private static String getDefaultMessage(int expectedDataType, boolean expectedMultivalue)
    {
        StringBuffer msgBuffer = new StringBuffer("Invalid data type. Expected ");
        if (expectedMultivalue)
        {
            msgBuffer.append("multi-valued ");
        }
        else
        {
            msgBuffer.append("single-valued ");
        }
        switch (expectedDataType)
        {
        case OdmaTypes.TYPE_STRING:
            msgBuffer.append("string");
            break;
        case OdmaTypes.TYPE_INTEGER:
            msgBuffer.append("integer");
            break;
        case OdmaTypes.TYPE_SHORT:
            msgBuffer.append("short");
            break;
        case OdmaTypes.TYPE_LONG:
            msgBuffer.append("long");
            break;
        case OdmaTypes.TYPE_FLOAT:
            msgBuffer.append("float");
            break;
        case OdmaTypes.TYPE_DOUBLE:
            msgBuffer.append("double");
            break;
        case OdmaTypes.TYPE_BOOLEAN:
            msgBuffer.append("boolean");
            break;
        case OdmaTypes.TYPE_DATETIME:
            msgBuffer.append("datetime");
            break;
        case OdmaTypes.TYPE_BLOB:
            msgBuffer.append("blob");
            break;
        case OdmaTypes.TYPE_REFERENCE:
            msgBuffer.append("object");
            break;
        case OdmaTypes.TYPE_CONTENT:
            msgBuffer.append("content");
            break;
        }
        return (msgBuffer.toString());
    }

    /**
     * 
     * @param expectedDataType
     *            the data type expected by the user
     * @param expectedMultivalue
     *            the multi-value / single-value property expected by the user
     * @param foundDataType
     * @param foundMultivalue
     * 
     * @return x
     */
    private static String getDefaultMessage(int expectedDataType, boolean expectedMultivalue, int foundDataType, boolean foundMultivalue)
    {
        StringBuffer msgBuffer = new StringBuffer("Invalid data type. Expected ");
        if (expectedMultivalue)
        {
            msgBuffer.append("multi-valued ");
        }
        else
        {
            msgBuffer.append("single-valued ");
        }
        switch (expectedDataType)
        {
        case OdmaTypes.TYPE_STRING:
            msgBuffer.append("string");
            break;
        case OdmaTypes.TYPE_INTEGER:
            msgBuffer.append("integer");
            break;
        case OdmaTypes.TYPE_SHORT:
            msgBuffer.append("short");
            break;
        case OdmaTypes.TYPE_LONG:
            msgBuffer.append("long");
            break;
        case OdmaTypes.TYPE_FLOAT:
            msgBuffer.append("float");
            break;
        case OdmaTypes.TYPE_DOUBLE:
            msgBuffer.append("double");
            break;
        case OdmaTypes.TYPE_BOOLEAN:
            msgBuffer.append("boolean");
            break;
        case OdmaTypes.TYPE_DATETIME:
            msgBuffer.append("datetime");
            break;
        case OdmaTypes.TYPE_BLOB:
            msgBuffer.append("blob");
            break;
        case OdmaTypes.TYPE_REFERENCE:
            msgBuffer.append("object");
            break;
        case OdmaTypes.TYPE_CONTENT:
            msgBuffer.append("content");
            break;
        }
        msgBuffer.append(" but found ");
        if (foundMultivalue)
        {
            msgBuffer.append("multi-valued ");
        }
        else
        {
            msgBuffer.append("single-valued ");
        }
        switch (foundDataType)
        {
        case OdmaTypes.TYPE_STRING:
            msgBuffer.append("string");
            break;
        case OdmaTypes.TYPE_INTEGER:
            msgBuffer.append("integer");
            break;
        case OdmaTypes.TYPE_SHORT:
            msgBuffer.append("short");
            break;
        case OdmaTypes.TYPE_LONG:
            msgBuffer.append("long");
            break;
        case OdmaTypes.TYPE_FLOAT:
            msgBuffer.append("float");
            break;
        case OdmaTypes.TYPE_DOUBLE:
            msgBuffer.append("double");
            break;
        case OdmaTypes.TYPE_BOOLEAN:
            msgBuffer.append("boolean");
            break;
        case OdmaTypes.TYPE_DATETIME:
            msgBuffer.append("datetime");
            break;
        case OdmaTypes.TYPE_BLOB:
            msgBuffer.append("blob");
            break;
        case OdmaTypes.TYPE_REFERENCE:
            msgBuffer.append("object");
            break;
        case OdmaTypes.TYPE_CONTENT:
            msgBuffer.append("content");
            break;
        }
        return (msgBuffer.toString());
    }

    /**
     * Returns the data type expected by the user.
     * 
     * \return the data type expected by the user
     */
    int getExpectedDataType()
    {
        return expectedDataType;
    }

    /**
     * Returns the multi-value / single-value property expected by the user.
     * 
     * \return the multi-value / single-value property expected by the user
     */
    bool isExpectedMultivalue()
    {
        return expectedMultivalue;
    }

    /**
     * 
     * @return x
     */
    bool hasFoundDataType()
    {
        return hasFound;
    }

    /**
     * 
     * @return x
     */
    int getFoundDataType()
    {
        return foundDataType;
    }

    /**
     * 
     * @return x
     */
    bool isFoundMultivalue()
    {
        return foundMultivalue;
    }

}

#endif
